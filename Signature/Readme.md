## Signature

- ECDSA

The digital signature algorithm used by Ethereum is called the Dual Elliptic Curve Digital Signature Algorithm (ECDSA), which is a digital signature algorithm based on the dual elliptic curve "private key-public key" pair.
It mainly plays three roles:<br>
1. **Identity authentication:** Prove that the signer is the holder of the private key.<br>
2. **Non-repudiation:** The sender cannot deny having sent the message.<br>
3. **Integrity:** By verifying the digital signature generated against the transmitted message, you can verify whether the message has been tampered with during transmission.<br>

The ECDSA standard consists of two parts:<br>
1. The signer uses the **private key** (private) to create a **signature** (public) on the **message** (public).<br>
2. Others use the **message** (public) and the **signature** (public) to recover the signer's **public key** (public) and verify the signature.<br>

For test purpose, **private key**, **public key**, **message**, **Ethereum signature message**, **signature** are as follows:<br>
<br>
*private key:* 0x227dbb8586117d55284e26620bc76534dfbd2394be34cf4a09cb775d593b6f2<br>
*public key:* 0xe16C1623c1AA7D919cd2241d8b36d9E79C1Be2A2<br>
*message:* 0x1bf2c0ce4546651a1a2feb457b39d891a6b83931cc2454434f39961345ac378c<br>
*Ethereum signature message:* 0xb42ca4636f721c7a331923e764587e98ec577cea1a185f60dfcc14dbb9bd900b<br>
*signature:* 0x390d704d7ab732ce034203599ee93dd5d3cb0d4d1d7c600ac11726659489773d559b12d220f99f41d17651b0c1c6a669d346a397f8541760d6b32a5725378b241c<br>

- Create a signature
1. Packaging messages.<br>
   In Ethereum's ECDSA standard, the signed message is the keccak256 hash of a set of data, which is bytes32 type. We can package any content we want to sign using the ***abi.encodePacked()*** function,<br>
   and then use ***keccak256()*** to calculate the hash as the message, the message in this example is obtained by an address type variable and a uint256 type(token's Id) variable.<br>
   ![getMessageHash](https://github.com/wls503pl/Ether_Evolution_/blob/ee/Signature/img/getMessageHash.png)
   
3. Calculate Ethereum Signature Message.<br>
   The message can be an executable transaction or any other form. In order to prevent users from signing malicious transactions by mistake, EIP191 advocates adding "\x19Ethereum Signed Message:\n32"<br>
   characters before the message and performing a keccak256 hash as an Ethereum signed message. Messages processed by the ***toEthSignedMessageHash()*** function cannot be used to execute transactions.<br>
   ![toEthSignedMessageHash](https://github.com/wls503pl/Ether_Evolution_/blob/ee/Signature/img/toEthSignedMessageHash.png)
   
3. Signature method.<br>
- Signing with wallet<br>
In daily operations, most users sign in this way. After getting the message that needs to be signed, we need to use the metamask wallet to sign it.<br>
The personal_sign method of metamask will automatically convert the message into an Ethereum signature message, and then initiate the signature. So we just need to enter the message and the signer wallet account<br>
(It should be noted that the input signer wallet account must be consistent with the account currently connected to metamask in order to be used)

- Signing with web3.py<br>
In batch calls, it is more preferable to use code for signing. The following is an implementation based on web3.py.<br>
<hr>
from web3 import Web3, HTTPProvider<br>
from eth_account.messages import encode_defunct<br>
<br>
private_key = "0x227dbb8586117d55284e26620bc76534dfbd2394be34cf4a09cb775d593b6f2b"<br>
address = "0x5B38Da6a701c568545dCfcB03FcB875f56beddC4"<br>
rpc = 'https://rpc.ankr.com/eth'<br>
w3 = Web3(HTTPProvider(rpc))<br>
<br>
// Package message<br>
msg = Web3.solidity_keccak(['address','uint256'], [address,0])<br>
print(f"message：{msg.hex()}")<br>
// Constructing a signable message<br>
message = encode_defunct(hexstr=msg.hex())<br>
// Signature<br>
signed_message = w3.eth.account.sign_message(message, private_key=private_key)<br>
print(f"signature：{signed_message['signature'].hex()}")<br>
<hr>

4. Verify the signature.<br>
In order to verify the signature, the verifier needs to have the **message**, the **signature**, and the **public key** used to sign it.
The reason we can verify the signature is that only the holder of the **private key** can generate such a signature for the transaction, and no one else can.
- Recover the public key from the signature and message
The signature is generated by a mathematical algorithm. Here we use the rsv signature, which contains information about the three values ​​r, s, and v.
Then, we can use r, s, v and the Ethereum signature message to obtain the public key. The ***recoverSigner()*** function implements the above steps.
It uses the Ethereum signed message **_msgHash** and signature **_signature** to recover the **public key**.<br>
![Recover Public Key](https://github.com/wls503pl/Ether_Evolution_/blob/ee/Signature/img/recoverPublicKey.png)

5. Compare the public keys and verify the signature.<br>
Next, we just need to compare the recovered public key with the signer's public key _signer to see if they are equal,<br>
if they are equal, the signature is valid, otherwise, the signature is invalid:<br>
![Compare Public Key](https://github.com/wls503pl/Ether_Evolution_/blob/ee/Signature/img/comparePbK.png)
